#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Batería de Aire.
\end_layout

\begin_layout Author
Claudio Acuña, Cristián Garrido, Guillermo Rojas.
\end_layout

\begin_layout Date
XX Junio 2013
\end_layout

\begin_layout Abstract
La batería virtual es una software que consiste permitir al usuario poder
 tocar una batería mediante el uso de un pc y herramientas adicionales (kinect
 y arduino) para poder emularla y darle la sensación al usuario de poder
 estar tocar una real, sin la necesidad de gastar tanto dinero comprando
 o arreglando una.
\end_layout

\begin_layout Abstract
Kinect es un hardware que tiene la opción de reconocimiento que le permitirá
 al usuario poder tocar dicha batería y ver cómo la toca, así no sólo el
 usuario toca una batería sino que también podrá verse sumergido así mismo
 tocarla dándole una gran sensación de participación.
\end_layout

\begin_layout Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Section
Introducción.
\end_layout

\begin_layout Standard
Hoy en día, la conexión con la música, es mucho más potente que en antaño.
 Antes tener música disponible y de calidad, era un lujo que sólo terratenientes
, generales y realeza podían costear.
 En la actualidad, sabemos que basta con un par de clicks.
 
\end_layout

\begin_layout Standard
Ahora tener música a la mano, es un privilegio de muchos, pero ¿somos todos
 capaces de generarla? Claramente no, sólo unos pocos privilegiados son
 capaces de crear y reproducir música de calidad.
 
\end_layout

\begin_layout Quotation
A la guitarra se le sacan notas, no lágrimas 
\end_layout

\begin_layout Quotation

\end_layout

\begin_layout Quotation
(Don Ramón).
\end_layout

\begin_layout Standard
En el presente hay diversos entornos y situaciones, capaces de emular situacione
s e instrumentos musicales tales como: TuxGuitar, Controladores MIDI, Fruitloops
, VirtualPiano, Dance Dance Revolution, Pump it up, Beatmanía Guitar Hero,
 entre tantos otros.
\end_layout

\begin_layout Standard
Hoy en día la música nos sugiere que mientras más participativa y amigable
 sea con su medio, más agradable y adaptable se volverá hacia usuario.
 Mientras más inmerso se encuentre en su mundo, mejor respuesta esperamos
 de él.
\end_layout

\begin_layout Standard
Más de alguna vez, hemos imitado a nuestros artistas mientras escuchamos
 sus canciones; surfear en público, tocar guitarras y baterías de aire...
 ¿es genial no? Nos sentimos vivos, donde se recrea ser un miembro más de
 la banda donde toca la música en vivo en frente de miles de personas, y
 nos sumergimos dentro de nuestra imaginación.
 Pero...
 ¿podremos algún día recrear estas situaciones moviendo simplemente nuestras
 manos? ¡Pues sí ese día ya llegó!
\end_layout

\begin_layout Standard
Esta situación era impensable 20 años atrás, pero todos sabemos que la realidad
 supera la ficción y es por esto que ayudados por el software y el hardware
 contemporáneo hemos logrado emular una batería “completamente de aire”.
\end_layout

\begin_layout Section
Objetivos
\end_layout

\begin_layout Standard
Construcción, configuración de una batería virtual, mediante la cual el
 usuario sea capaz de poder sentir como si realmente estuviese tocando una
 bateria real, mediante las tecnologías necesarias.
\end_layout

\begin_layout Section
Marco Teórico.
\end_layout

\begin_layout Standard
Bajo el tema de las tecnologías, las cuales tienen mucha interacción con
 el usuario, los desarrolladores se han apoyado en el siguiente software:
\end_layout

\begin_layout Itemize
Processing: Es un lenguaje de programación, entorno de desarrollo, y la
 comunitario en línea.
 Desde el año 2001, Processing ha promovido la alfabetización de software
 dentro de las artes visuales y la alfabetización visual dentro de la tecnología.
 Inicialmente creado para servir como un cuaderno de bocetos de software
 y para enseñar los fundamentos de programación de computadoras dentro de
 un contexto visual, Processing se ha convertido en una herramienta de desarroll
o para los profesionales.
 Hoy en día, hay decenas de miles de estudiantes, artistas, diseñadores,
 investigadores y aficionados que utilizan procesamiento para el aprendizaje,
 creación de prototipos y producción.
\end_layout

\begin_layout Itemize
Wiimote: Wii Remote es el mando principal de la consola Wii de Nintendo,
 el cual también es compatible con la consola Wii U.
 Sus características más destacables son la capacidad de detección de movimiento
 en el espacio y la habilidad de apuntar hacia objetos en la pantalla.
 El diseño del Wii Remote no se basa en los tradicionales mandos para los
 videojuegos.
 A diferencia de ellos, es similar a un control remoto de televisión, creado
 para ser utilizado en una sola mano y de la manera más intuitiva posible.
 En su cara frontal, el Wiimote presenta los botones "A", "1", "2", "+",
 "-", "HOME" y la cruz de direcciones, más un botón "POWER" para apagar
 la consola, algo inédito hasta entonces.
 En la parte anterior sólo presenta el botón "B", en un formato similar
 a un gatillo.
 Además, en su parte frontal incluye un altavoz y cuatro luces numeradas
 que indican el número de jugador al que corresponde tal mando y ver el
 tiempo de vida de la batería.
 En la parte inferior se encuentra el puerto de expansión del mando y viene
 unida una correa de seguridad que se amarra a la muñeca para evitar soltar
 y dañar el control de forma accidental.
\end_layout

\begin_layout Itemize
Arduino: Es una plataforma de electrónica abierta para la creación de prototipos
 basada en software y hardware flexibles y fáciles de usar.
 Se creó para artistas, diseñadores, aficionados y cualquiera interesado
 en crear entornos u objetos interactivos.
 Arduino puede tomar información del entorno a través de sus pines de entrada
 de toda una gama de sensores y puede afectar aquello que le rodea controlando
 luces, motores y otros actuadores.
 El microcontrolador en la placa Arduino se programa mediante el lenguaje
 de programación Arduino (basado en Wiring) y el entorno de desarrollo Arduino
 (basado en Processing).
 Los proyectos hechos con Arduino pueden ejecutarse sin necesidad de conectar
 a un ordenador, si bien tienen la posibilidad de hacerlo y comunicar con
 diferentes tipos de software (p.ej.
 Flash, Processing, MaxMSP).
 Las placas pueden ser hechas a mano o compradas montadas de fábrica; el
 software puede ser descargado de forma gratuita.
 Los ficheros de diseño de referencia (CAD) están disponibles bajo una licencia
 abierta, así pues eres libre de adaptarlos a tus necesidades.
 Arduino recibió una Mención Honorífica en la sección Digital Communities
 de la edición del 2006 del Ars Electronica Prix.
 El equipo Arduino (Arduino team) es: Massimo Banzi, David Cuartielles,
 Tom Igoe, Gianluca Martino, and David Mellis
\end_layout

\begin_layout Itemize
Kinect: Kinect para Xbox 360, o simplemente Kinect (originalmente conocido
 por el nombre EN clave Project Natal), es un controlador de juegos libre
 y entretenimiento creado por Alex Kipman, desarrollado por Microsoft para
 la videoconsola Xbox 360, y desde junio del 2011 para PC a través de Windows
 7 y Windows 8.
 Kinect permite a los usuarios controlar e interactuar con la consola sin
 necesidad de tener contacto físico con un controlador de videojuegos tradiciona
l, mediante una interfaz natural de usuario que reconoce gestos, comandos
 de voz, y objetos e imágenes.
 El dispositivo tiene como objetivo primordial aumentar el uso de la Xbox
 360, más allá de la base de jugadores que posee en la actualidad.
 En sí, Kinect compite con los sistemas Wiimote con Wii MotionPlus y PlayStation
 Move, que también controlan el movimiento para las consolas Wii y PlayStation
 3, respectivamente.
\end_layout

\begin_layout Itemize
Cualquier computadora con un sistema operativo; windows 7 o superior, GNU/Linux
 (cualquierda de sus distros)
\begin_inset Foot
status open

\begin_layout Plain Layout
Las cuales por razones más adelante abandonamos
\end_layout

\end_inset

 de 32 ó 64 bits.
\end_layout

\begin_layout Section
Materiales utilizados
\end_layout

\begin_layout Itemize
Placa de Desarrollo Arduino uno-R3
\end_layout

\begin_layout Itemize
Cable USB (A-B)
\end_layout

\begin_layout Itemize
Protoboard
\end_layout

\begin_layout Itemize
Leds Infrarrojos
\end_layout

\begin_layout Itemize
Wiimote
\end_layout

\begin_layout Itemize
Canaleta de luz
\end_layout

\begin_layout Itemize
Pulsadores
\end_layout

\begin_layout Itemize
Resistor (10 Kohm)
\end_layout

\begin_layout Itemize
Banda elástica
\end_layout

\begin_layout Section
Procedimiento experimental:
\end_layout

\begin_layout Subsection
La “no solución”
\end_layout

\begin_layout Standard
En primera instancia, coincidimos que era mucho más factible, realizar este
 proyecto, basándonos en la utilización de wiimote+nunchuck, siendo éstos
 la emulación de las baquetas, dando una experiencia mucho más real.
\end_layout

\begin_layout Standard
Utilizando las librerías Cwid en conjunto con wmgui y la transferencia de
 datos por bluetooth(BlueZ).
 Para una mejor captación de movimiento se procede a construir un senso-bar
 para poder tener una mejor conexión entre el wiimote y la computadora.
 Dicha barra, consiste básicamente en colocar 4 leds infrarrojos, siendo
 alimentados por una computadora por medio de un cable usb.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(Insertar foto del senso bar)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(insertar una foto de circuitado)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Luego se empezó a identificar los distintos medios(lenguajes de programación
 y librerías), para poder realizar un sencilla aplicación para wiimote y
 así a través de estos datos recopilados poder a la construcción en bruto
 de nuestra batería virtual.
 Donde la búsqueda exhaustiva, lograron sus primeros frutos pudiendo identificar
 un IDE amigable con el usuario(Programadores o Creadores), basada en java
 llamada “Processing”, donde a través de ella se podrá realizar tanto el
 diseño como el funcionamiento en sí (codigo fuente), a continuación se
 procedió a ver de qué manera se podría conectar nuestra IDE con wiimote,
 donde una vez más se requirió de los buscadores de internet para encontrar
 una librería.
 Afortunadamente existen muchas librerías en lenguajes diferentes, pero
 que no eran amigable con la IDE a utilizar, después de una larga búsqueda
 se logró llegar con una en especifica llamada (No me acuerdo Berracos )
 , logrando su instalación correspondiente(Link guia de instalación) y ejecutand
o un simple ejemplo de prueba se pudo lograr con efectividad conectar nuestro
 wiimote con processing y desarrollar un simple ejemplo.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize\sffamily},breaklines=true,extendedchars=true,language={[AspectJ]Java},numbers=left,numberstyle={\footnotesize}"
inline false
status open

\begin_layout Plain Layout

import ddf.minim.*;
\end_layout

\begin_layout Plain Layout

import lll.Loc.*;
\end_layout

\begin_layout Plain Layout

import lll.wrj4P5.*;
\end_layout

\begin_layout Plain Layout

Wrj4P5 wii;
\end_layout

\begin_layout Plain Layout

Minim minim;
\end_layout

\begin_layout Plain Layout

Minim mini;
\end_layout

\begin_layout Plain Layout

AudioPlayer bmusic;
\end_layout

\begin_layout Plain Layout

AudioPlayer playe;
\end_layout

\begin_layout Plain Layout

int spazio=50;
\end_layout

\begin_layout Plain Layout

int value;
\end_layout

\begin_layout Plain Layout

void setup() {
\end_layout

\begin_layout Plain Layout

  size(300,300,P3D);
\end_layout

\begin_layout Plain Layout

  wii=new Wrj4P5(this);
\end_layout

\begin_layout Plain Layout

  wii.connect();
\end_layout

\begin_layout Plain Layout

  minim= new Minim(this);
\end_layout

\begin_layout Plain Layout

  mini= new Minim(this);
\end_layout

\begin_layout Plain Layout

  bmusic = minim.loadFile("Crash.wav", 1024);
\end_layout

\begin_layout Plain Layout

  playe = mini.loadFile("LowTom.wav");
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

void draw() {
\end_layout

\begin_layout Plain Layout

  background(0);
\end_layout

\begin_layout Plain Layout

  stroke(255);
\end_layout

\begin_layout Plain Layout

  translate(100/1,200/1,0);
\end_layout

\begin_layout Plain Layout

  lights();
\end_layout

\begin_layout Plain Layout

  Loc p=wii.rimokon.irLights[0];
\end_layout

\begin_layout Plain Layout

  Loc a=wii.rimokon.irLights[1];
\end_layout

\begin_layout Plain Layout

  Loc b=wii.rimokon.irLights[2];
\end_layout

\begin_layout Plain Layout

  Loc c=wii.rimokon.irLights[3];
\end_layout

\begin_layout Plain Layout

  rotateX((int) (wii.rimokon.senced.x*5+10));
\end_layout

\begin_layout Plain Layout

  rotateY((int) (wii.rimokon.senced.y*5+10));
\end_layout

\begin_layout Plain Layout

  rotateZ((int) (wii.rimokon.senced.z*5+10));
\end_layout

\begin_layout Plain Layout

  box(100,100,100);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

void buttonPressed(RimokonEvent evt, int rid) {
\end_layout

\begin_layout Plain Layout

   if (evt.wasPressed(RimokonEvent.TWO)){ 
\end_layout

\begin_layout Plain Layout

   //song= minim.loadFile("Crash.wav");
\end_layout

\begin_layout Plain Layout

   //song.play();
\end_layout

\begin_layout Plain Layout

   //value=1;
\end_layout

\begin_layout Plain Layout

  //bmusic.rewind();
\end_layout

\begin_layout Plain Layout

  //play the file
\end_layout

\begin_layout Plain Layout

  bmusic.play();
\end_layout

\begin_layout Plain Layout

  bmusic.rewind();
\end_layout

\begin_layout Plain Layout

  //value=1;
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

  if (evt.wasPressed(RimokonEvent.ONE)){
\end_layout

\begin_layout Plain Layout

  //play the file
\end_layout

\begin_layout Plain Layout

  //playe = minim.loadFile("LowTom.wav",1024);
\end_layout

\begin_layout Plain Layout

  playe.play();
\end_layout

\begin_layout Plain Layout

  playe.rewind(); 
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   if (evt.wasPressed(RimokonEvent.B)) println("B");
\end_layout

\begin_layout Plain Layout

   if (evt.wasPressed(RimokonEvent.A)) println("A");
\end_layout

\begin_layout Plain Layout

   if (evt.wasPressed(RimokonEvent.MINUS)) println("Minus");
\end_layout

\begin_layout Plain Layout

   if (evt.wasPressed(RimokonEvent.HOME)) println("Home");
\end_layout

\begin_layout Plain Layout

   if (evt.wasPressed(RimokonEvent.LEFT)) println("Left");
\end_layout

\begin_layout Plain Layout

   if (evt.wasPressed(RimokonEvent.RIGHT)) println("Right");
\end_layout

\begin_layout Plain Layout

   if (evt.wasPressed(RimokonEvent.DOWN)) println("Down");
\end_layout

\begin_layout Plain Layout

   if (evt.wasPressed(RimokonEvent.UP)) println("Up");
\end_layout

\begin_layout Plain Layout

   if (evt.wasPressed(RimokonEvent.PLUS)) println("Plus");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void stop(){
\end_layout

\begin_layout Plain Layout

  // always close Minim audio classes when you are done with them
\end_layout

\begin_layout Plain Layout

  bmusic.close();
\end_layout

\begin_layout Plain Layout

  playe.close();
\end_layout

\begin_layout Plain Layout

  minim.stop();
\end_layout

\begin_layout Plain Layout

  super.stop();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Tocar un sonido con un botón en Wii
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ahora es el turno de arduino.
 Arduino es una placa de desarrollo que cuenta con su propia IDE, pero para
 el desarrollo del proyecto se necesita que se conecte de igual forma con
 processing para la futura construcción del pedal de bateria, donde se procedió
 a la identificación de librerías correspondientes para processing y además
 un código ejemplo de aplicaciones realizadas anteriormente.
\end_layout

\begin_layout Standard
Ya dispuesto con las librerías anteriormente dichas y instaladas para el
 funcionamiento del wiimote y arduino se procedió a la construcción de la
 batería virtual y como primer objetivo identificar los botones del wiimote
 con el objetivo final de que todos y cada uno de ellos podía efectuar un
 sonido en específico los pasos para lograr el desarrollo de tal tarea fueron
 los siguientes:
\end_layout

\begin_layout Standard
Identificar cada unos de los botones referente a la representación mediante
 código a través de Proccesing y la acciones que permitan el correcto funcionami
ento para el proyecto en sí.
\end_layout

\begin_layout Standard
Una vez identificada cada función correspondiente a cada botón se procede
 a programar un sonido en específico, para esto se descargaron los diferentes
 sonidos en .wav de tal manera de incorporarlos en cada función del botón.
\end_layout

\begin_layout Standard
Una vez descargado y logrado el correcto funcionamiento de la funciones
 de los botones se procede a ocupar la librería minin de sonido, la cual
 viene instalada por defecto en proccesing y a través de ella lograr el
 correcto manejo de sonidos con los botones del wiimote.
\end_layout

\begin_layout Standard
En el código, se asigna a cada botón del control un sonido, es decir, cada
 botón representará un tambor o platillo.
 Los sonidos son designados arbitrariamente
\end_layout

\begin_layout Standard
Es aquí en donde se hará una pausa en este punto, para efectuar un reporte
 de un bug que no se pudo solucionar y conllevo a la paralización total
 del proyecto de la batería virtual con baquetas usado el wiimote.
 Lamentablemente la documentación de este bug es escasa y poco clara al
 momento de solucionar el problema, cabe recalcar que la explicación que
 se realizara a continuación que se produce en distribuciones linux que
 tiene como base a ubuntu como por ejemplo, mint , kubuntu, ubuntu, y fedora
 etc.
 (Desconocemos si ocurre en Debian).
\end_layout

\begin_layout Standard
Al momento de cargar el sonido en el void setup se produce el siguiente
 error (foto).
\end_layout

\begin_layout Standard
Se comenzó por revisar el codigo sexistíaia algún error de sintaxis o solamente
 de la elaboración del algoritmo, donde se pudo identificar que el algoritmo
 no era correcto, entonces se procedió a revisar el problema mediante los
 buscadores de internet ubicando la falla en sí, identificándose como error
 de comunicación entre la librería minin y el jdk de java.
\end_layout

\begin_layout Standard
Se comenzó a buscar una solución para que el correcto funcionamiento del
 código identificando que el problema solo era válido en distribuciones
 que tienen como base a ubuntu.
\end_layout

\begin_layout Standard
Finalmente se encontraron algunos fix que se dejan a continuación que se
 aplicaron mediante terminal sin tener resultados fructíferos.
\end_layout

\begin_layout Standard
Ya sin ninguna opción de arreglar el programa se procedió a probar diferentes
 distribuciones de Sistemas operativos que no estuvieran basadas en ubuntu,
 partiendo por Fedora.
 Al momento de inicializar fedora e instalar todo lo correspondiente para
 el funcionamiento del código lamentablemente lanzó el mismo error nuevamente.
 Así que se decidió migrar a Windows.
\end_layout

\begin_layout Standard
En windows nuevamente se instalaron las librerías correspondientes para
 el funcionamiento del código, pero en esta circunstancia ahora no existía
 el problema de la librería minin con java, ahora existía otro que era wiimote
 con bluetooth donde la librería de Wiimote se nos hizo imposible establecer
 una comunicación estable entre wiimotes y processing.
\end_layout

\begin_layout Subsection
Solución con Kinect.
\end_layout

\begin_layout Subsubsection
Logrando el objetivo:
\end_layout

\begin_layout Standard
Debido a la ineficacia y poca productividad, por parte de un problemas de
 licencias y bugs de librerías por parte de Linux(Ubuntu, Mint, y Fedora),
 se decidió emigrar del wiimote para recaer sobre la máquina de Microsoft.
\end_layout

\begin_layout Standard
Cambiando el paradigma de acelerómetros y secuencia de de botones, se enfocó
 a la captura de movimiento.
 Siendo ésta una solución más idónea y cómoda para el equipo de desarrolladores.
\end_layout

\begin_layout Standard
Sentándose en los hombros de gigantes.
\end_layout

\begin_layout Standard
Navegando por la web, se encontró con proyectos similares, a los cuales,
 discutimos, modificamos, evolucionamos y evaluamos la mejor opción para
 adaptarnos éste.
\end_layout

\begin_layout Standard
Creación de un nuevo escenario:
\end_layout

\begin_layout Standard
Para poder utilizar Kinect y processing es necesario instalar ciertos drivers
 y librerías para que funcione conrrectamente
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Link de las librerías
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Luego de haberse configurado todo, procedemos a ejecutar e interpretar el
 código (link).
 Resulta bastante beneficioso para el equipo, que éste funciona, pero no
 de una forma ideal propuesta en un principio.
\end_layout

\begin_layout Standard
Añadiendo elementos:
\end_layout

\begin_layout Standard
Ahora se procede a agregar un botón, de tipo pulsador, el cual será utilizado
 con el pie, logrando una experiencia mucho más realista para el usuario-jugador.
 Es aquí donde entra en juego Arduino.
 Desde Processing, es posible llamar librerías capaces de conectarse con
 Arduino.
 Con esto dicho, se pudo establecer un puente de comunicación utilizando
 el siguiente ejemplo:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},breaklines=true,extendedchars=true,language={[AspectJ]Java},numbers=left,numberstyle={\footnotesize}"
inline false
status open

\begin_layout Plain Layout

import processing.serial.*;
\end_layout

\begin_layout Plain Layout

import cc.arduino.*;
\end_layout

\begin_layout Plain Layout

import ddf.minim.*;
\end_layout

\begin_layout Plain Layout

AudioPlayer player;
\end_layout

\begin_layout Plain Layout

Minim minim;
\end_layout

\begin_layout Plain Layout

Arduino arduino;
\end_layout

\begin_layout Plain Layout

int switchPin = 2;
\end_layout

\begin_layout Plain Layout

void setup() {
\end_layout

\begin_layout Plain Layout

minim = new Minim(this);
\end_layout

\begin_layout Plain Layout

player = minim.loadFile("Bass.wav");
\end_layout

\begin_layout Plain Layout

player.play();
\end_layout

\begin_layout Plain Layout

smooth();
\end_layout

\begin_layout Plain Layout

size(200, 200);
\end_layout

\begin_layout Plain Layout

arduino = new Arduino(this, Arduino.list()[0], 57600);
\end_layout

\begin_layout Plain Layout

arduino.pinMode(switchPin, Arduino.INPUT);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void draw() {
\end_layout

\begin_layout Plain Layout

if(arduino.digitalRead(switchPin)==Arduino.LOW) { // Testea el estado de entrada
 2
\end_layout

\begin_layout Plain Layout

background(255, 0, 0); // Si el estado es bajo, sin pulsar pone el fondo
 rojo
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

background(0, 0, 0); // Si el estado es alto, pulsado pone fondo negro
\end_layout

\begin_layout Plain Layout

player.rewind();
\end_layout

\begin_layout Plain Layout

player.play();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Obteniendo un sonido, por medio de arduino
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(chantamos un par de fotos)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La diferencia que se estableció, con el ejemplo proporcionado por la web
 de Arduino, fue que en vez de iluminar un led, reprodujera sonido de un
 bombo de batería de 32”.
\end_layout

\begin_layout Section
Resultado final.
\end_layout

\begin_layout Standard
Una foto vale mil palabras, pero un video vale mil fotos.
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
target "http://youtu.be/qib120aztOE"

\end_inset


\end_layout

\begin_layout Section
Código final.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\tiny},breaklines=true,language={[AspectJ]Java},numbers=left,numberstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Autores/ Authors:
\end_layout

\begin_layout Plain Layout

Guillermo Rojas       guillermorojaslema@gmail.com
\end_layout

\begin_layout Plain Layout

Claudio Acuña         claudioacunacuna@gmail.com
\end_layout

\begin_layout Plain Layout

Cristian Garrido      cristian.garrido@ceinf.cl
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

Based on AdverseDeviant's work
\end_layout

\begin_layout Plain Layout

Version: 0.9
\end_layout

\begin_layout Plain Layout

Thank's to all that people who made possible this project
\end_layout

\begin_layout Plain Layout

Gracias a toda esa gente que hizo posible este proyecto
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Importaciones de clases
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

import SimpleOpenNI.*; /*Librería para conectar Kinect*/
\end_layout

\begin_layout Plain Layout

import ddf.minim.*; /*Librería de sonido*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import processing.serial.*; 
\end_layout

\begin_layout Plain Layout

import cc.arduino.*; /*Importa arduino*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Variables.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

// Valor vectorial para las manos.
\end_layout

\begin_layout Plain Layout

PVector SKEL_LEFT_HAND = new PVector();
\end_layout

\begin_layout Plain Layout

PVector SKEL_RIGHT_HAND = new PVector();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Coordenadas XYZ para las manos.
\end_layout

\begin_layout Plain Layout

float SKEL_LEFT_HANDX;
\end_layout

\begin_layout Plain Layout

float SKEL_LEFT_HANDY;
\end_layout

\begin_layout Plain Layout

float SKEL_LEFT_HANDZ;
\end_layout

\begin_layout Plain Layout

float SKEL_RIGHT_HANDX;
\end_layout

\begin_layout Plain Layout

float SKEL_RIGHT_HANDY;
\end_layout

\begin_layout Plain Layout

float SKEL_RIGHT_HANDZ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Tamaño de los puntos dibujados en cada jint
\end_layout

\begin_layout Plain Layout

float dotSize = 30;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// De vector a un escalar de radio
\end_layout

\begin_layout Plain Layout

float vectorScalar = 525;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Variable de imagen
\end_layout

\begin_layout Plain Layout

PImage img;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Objeto kinect para interactuar con Kinect
\end_layout

\begin_layout Plain Layout

SimpleOpenNI kinect;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Variables de reproducción de sonido
\end_layout

\begin_layout Plain Layout

Minim minim;
\end_layout

\begin_layout Plain Layout

AudioPlayer player;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Arduino arduino;
\end_layout

\begin_layout Plain Layout

int switchPin = 2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Valores booleanos para las manos en la batería
\end_layout

\begin_layout Plain Layout

boolean leftTopDrum = false;
\end_layout

\begin_layout Plain Layout

boolean rightTopDrum = false;
\end_layout

\begin_layout Plain Layout

boolean rightBottomDrum = false;
\end_layout

\begin_layout Plain Layout

boolean snareDrum = false;
\end_layout

\begin_layout Plain Layout

boolean hihatDrum = false;
\end_layout

\begin_layout Plain Layout

boolean leftCrashDrum = false;
\end_layout

\begin_layout Plain Layout

boolean centerCrashDrum = false;
\end_layout

\begin_layout Plain Layout

boolean rightCrashDrum = false;
\end_layout

\begin_layout Plain Layout

boolean kickDrum = false;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Método Setup.
 Prepara la kinect y dibuja una ventana.
 Carga una imagen y los componentes de audio.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void setup() 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  // Crea un nuevo objeto kinect
\end_layout

\begin_layout Plain Layout

  kinect = new SimpleOpenNI(this); 
\end_layout

\begin_layout Plain Layout

  // Efecto de espejo, para obtener una imagen más natural.
\end_layout

\begin_layout Plain Layout

  kinect.setMirror(true); 
\end_layout

\begin_layout Plain Layout

  // Habilita la generación de depthMap 
\end_layout

\begin_layout Plain Layout

  kinect.enableDepth(); 
\end_layout

\begin_layout Plain Layout

  // habilita el sensor RGB
\end_layout

\begin_layout Plain Layout

  kinect.enableRGB();
\end_layout

\begin_layout Plain Layout

  // Habilita la generación de esqueleto para los puntos
\end_layout

\begin_layout Plain Layout

  kinect.enableUser(SimpleOpenNI.SKEL_PROFILE_ALL);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Crea un objeto arduino 
\end_layout

\begin_layout Plain Layout

  arduino = new Arduino(this, Arduino.list()[0], 57600);
\end_layout

\begin_layout Plain Layout

  // Prepara el bloque 2 en este caso para recibir impulsos
\end_layout

\begin_layout Plain Layout

  arduino.pinMode(switchPin, Arduino.INPUT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Crea una ventana del tamaño dela información de profundidad (depth)
\end_layout

\begin_layout Plain Layout

  size(kinect.depthWidth(), kinect.depthHeight()); 
\end_layout

\begin_layout Plain Layout

  // Color de fondo de la ventana,
\end_layout

\begin_layout Plain Layout

  background(200,0,0);
\end_layout

\begin_layout Plain Layout

  // El color para dibujar es rojo
\end_layout

\begin_layout Plain Layout

  stroke(255,0,0);
\end_layout

\begin_layout Plain Layout

  // Grosor de las lineas es suave 
\end_layout

\begin_layout Plain Layout

  strokeWeight(1);
\end_layout

\begin_layout Plain Layout

  // Sin suavidad
\end_layout

\begin_layout Plain Layout

  smooth();
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Carga la imagen de una batería genérica
\end_layout

\begin_layout Plain Layout

  img = loadImage("drumset.png");
\end_layout

\begin_layout Plain Layout

  // Carga los sonidos
\end_layout

\begin_layout Plain Layout

  minim = new Minim(this);
\end_layout

\begin_layout Plain Layout

} // void setup()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Método de dibujar.
 Se repite por siempre.
 Actualiza la cámara 
\end_layout

\begin_layout Plain Layout

de la kinecty dibuna una imagen en la ventana.
 Si Kinect está 
\end_layout

\begin_layout Plain Layout

rastreando entonces captura las coordenadas de manos y las 
\end_layout

\begin_layout Plain Layout

imprime.
 Revisa si ve que las manos del usuario están en el 
\end_layout

\begin_layout Plain Layout

rango del set de batería.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void draw() 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  //Actualiza la cámara de Kinect
\end_layout

\begin_layout Plain Layout

  kinect.update(); 
\end_layout

\begin_layout Plain Layout

  //Dibuja una imagen rgb en las coordenadas (0,0)
\end_layout

\begin_layout Plain Layout

  image(kinect.rgbImage(),0,0);
\end_layout

\begin_layout Plain Layout

  //Dibuja una batería en las coordenadas (100,200)
\end_layout

\begin_layout Plain Layout

  image(img,100,200);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Si Kinect está rastreando al usuario 1
\end_layout

\begin_layout Plain Layout

  if (kinect.isTrackingSkeleton(1)) 
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

    getCoordinates();
\end_layout

\begin_layout Plain Layout

    printHandCoordinates();
\end_layout

\begin_layout Plain Layout

    // Revisa que cada tambor para ver si las manos está en proximidad
\end_layout

\begin_layout Plain Layout

    leftTopDrum();
\end_layout

\begin_layout Plain Layout

    rightTopDrum();
\end_layout

\begin_layout Plain Layout

    rightBottomDrum();
\end_layout

\begin_layout Plain Layout

    snareDrum();
\end_layout

\begin_layout Plain Layout

    hihatDrum();
\end_layout

\begin_layout Plain Layout

    leftCrashDrum();
\end_layout

\begin_layout Plain Layout

    centerCrashDrum();
\end_layout

\begin_layout Plain Layout

    rightCrashDrum();
\end_layout

\begin_layout Plain Layout

    kickDrum();
\end_layout

\begin_layout Plain Layout

  } // Si el rastreo del esqueleto funciona, une los puntos
\end_layout

\begin_layout Plain Layout

} // void draw() 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Llamado cuando un nuevo usuario es encontrado.
 Imprime un nuevo ID e usuario
\end_layout

\begin_layout Plain Layout

Y comienza la detencción de pose si el rastreo de esqueleto no está habilitado.
\end_layout

\begin_layout Plain Layout

Si lo está entonces termina el método.
 Input es "int user ID" de un nuevo usuario.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void onNewUser(int userId) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  println("onNewUser - userId: " + userId); 
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  if (kinect.isTrackingSkeleton(1)) 
\end_layout

\begin_layout Plain Layout

    return; 
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  println(" start pose detection"); 
\end_layout

\begin_layout Plain Layout

  kinect.startPoseDetection("Psi", userId);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

} // void onNewUser(int userId)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Llamado cuando un usuario se ha perdido.
 Imprime el ID del usuario perdido
\end_layout

\begin_layout Plain Layout

Input es "int userId" del usuario perdido.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void onLostUser(int userId) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  println("onLostUser - userId: " + userId); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Llamado cuando la posicionamiento ha sido detectada.
 Se detiene la detección y
\end_layout

\begin_layout Plain Layout

solicita un calibración de esqueleto.
 Input es String de la posición detectada
\end_layout

\begin_layout Plain Layout

e int "user ID".
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void onStartPose(String pose, int userId) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  println("onStartPose - userId: " + userId + ", pose: " + pose); 
\end_layout

\begin_layout Plain Layout

  println(" stop pose detection"); 
\end_layout

\begin_layout Plain Layout

  kinect.stopPoseDetection(userId); 
\end_layout

\begin_layout Plain Layout

  kinect.requestCalibrationSkeleton(userId, true); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Llamado cuando un posicionamiento ha terminado.
\end_layout

\begin_layout Plain Layout

Input es String de la posición detectada e int "user ID".
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void onEndPose(String pose, int userId)
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  println("onEndPose - userId: " + userId + ", pose: " + pose); 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Llamado cuando la calibración de esqueleto comienza.
 Input es "int user ID".
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void onStartCalibration(int userId) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  println("onStartCalibration - userId: " + userId); 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Llamado cuando la calibración de esqueleto termina.
 Si la calibración
\end_layout

\begin_layout Plain Layout

ha sido exitosa, entonces comienza a rastrear el esqueleto, de lo contrario
\end_layout

\begin_layout Plain Layout

comience la detección de posicionamiento de nuevo.
 Input es "int user ID and booleano
\end_layout

\begin_layout Plain Layout

si el usuario ha sido con éxito calibrado.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void onEndCalibration(int userId, boolean successfull)
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  println("onEndCalibration - userId: " + userId + ", successfull: " + successfu
ll); 
\end_layout

\begin_layout Plain Layout

  if (successfull) 
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

    println(" User calibrated !!!"); 
\end_layout

\begin_layout Plain Layout

    kinect.startTrackingSkeleton(userId); 
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

  else 
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

    println(" Failed to calibrate user !!!"); 
\end_layout

\begin_layout Plain Layout

    println(" Start pose detection"); 
\end_layout

\begin_layout Plain Layout

    kinect.startPoseDetection("Psi", userId); 
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Obtiene las coordenadas XYZ de las manos rastreadas.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/ 
\end_layout

\begin_layout Plain Layout

void getCoordinates() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  // Obtiene la posicion de las manos
\end_layout

\begin_layout Plain Layout

  kinect.getJointPositionSkeleton(1,SimpleOpenNI.SKEL_LEFT_HAND,SKEL_LEFT_HAND);
\end_layout

\begin_layout Plain Layout

  kinect.getJointPositionSkeleton(1,SimpleOpenNI.SKEL_RIGHT_HAND,SKEL_RIGHT_HAND);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Convierte a punto de mundo real a espacio proyectivo
\end_layout

\begin_layout Plain Layout

  kinect.convertRealWorldToProjective(SKEL_LEFT_HAND,SKEL_LEFT_HAND);
\end_layout

\begin_layout Plain Layout

  kinect.convertRealWorldToProjective(SKEL_RIGHT_HAND,SKEL_RIGHT_HAND);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Escala el vector z de cada punto a forma escalar
\end_layout

\begin_layout Plain Layout

  SKEL_LEFT_HANDX = (vectorScalar/SKEL_LEFT_HAND.x);
\end_layout

\begin_layout Plain Layout

  SKEL_RIGHT_HANDX = (vectorScalar/SKEL_RIGHT_HAND.x);
\end_layout

\begin_layout Plain Layout

  SKEL_LEFT_HANDY = (vectorScalar/SKEL_LEFT_HAND.y);
\end_layout

\begin_layout Plain Layout

  SKEL_RIGHT_HANDY = (vectorScalar/SKEL_RIGHT_HAND.y);
\end_layout

\begin_layout Plain Layout

  SKEL_LEFT_HANDZ = (vectorScalar/SKEL_LEFT_HAND.z);
\end_layout

\begin_layout Plain Layout

  SKEL_RIGHT_HANDZ = (vectorScalar/SKEL_RIGHT_HAND.z);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // Rellenea el punto como rojo.
\end_layout

\begin_layout Plain Layout

  fill(255,0,0); 
\end_layout

\begin_layout Plain Layout

  ellipse(SKEL_LEFT_HAND.x,SKEL_LEFT_HAND.y, SKEL_LEFT_HANDZ*dotSize,SKEL_LEFT_HAN
DZ*dotSize);
\end_layout

\begin_layout Plain Layout

  ellipse(SKEL_RIGHT_HAND.x,SKEL_RIGHT_HAND.y, SKEL_RIGHT_HANDZ*dotSize,SKEL_RIGHT
_HANDZ*dotSize);
\end_layout

\begin_layout Plain Layout

} // void getCoordinates()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*-----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Imprime las coordenadas XYZ en el monitor serial.
 Falta debuggeo
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void printHandCoordinates()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  println("Left hand XYZ: " + SKEL_LEFT_HAND.x + " " + SKEL_LEFT_HAND.y +
 " "
\end_layout

\begin_layout Plain Layout

          + SKEL_LEFT_HAND.z);
\end_layout

\begin_layout Plain Layout

  println("right hand XYZ: " + SKEL_RIGHT_HAND.x + " " + SKEL_RIGHT_HAND.y
 + " "
\end_layout

\begin_layout Plain Layout

          + SKEL_RIGHT_HAND.z);
\end_layout

\begin_layout Plain Layout

} // void getHandCoordinates()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Si las manos del usuario son rastreadas en el area del tomb izquierdo, entonces
 toque un sonido.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void leftTopDrum()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if((SKEL_LEFT_HAND.x > 250 & SKEL_LEFT_HAND.x < 260
\end_layout

\begin_layout Plain Layout

    & SKEL_LEFT_HAND.y > 280 & SKEL_LEFT_HAND.y < 290 
\end_layout

\begin_layout Plain Layout

    & leftTopDrum == false) 
\end_layout

\begin_layout Plain Layout

    | (SKEL_RIGHT_HAND.x > 250 & SKEL_RIGHT_HAND.x < 260
\end_layout

\begin_layout Plain Layout

    & SKEL_RIGHT_HAND.y > 280 & SKEL_RIGHT_HAND.y < 290 
\end_layout

\begin_layout Plain Layout

    & leftTopDrum == false))
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      // cargue el sonido
\end_layout

\begin_layout Plain Layout

      player = minim.loadFile("leftTopDrum.wav");
\end_layout

\begin_layout Plain Layout

      // reproduzca el archivo
\end_layout

\begin_layout Plain Layout

      player.play();
\end_layout

\begin_layout Plain Layout

      leftTopDrum = true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      leftTopDrum = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} // void leftTopDrum()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Si las manos del usuario son rastreadas en el area del tomb de arriba derecho,
\end_layout

\begin_layout Plain Layout

entonces toque un sonido.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void rightTopDrum()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if((SKEL_LEFT_HAND.x > 325 & SKEL_LEFT_HAND.x < 335
\end_layout

\begin_layout Plain Layout

    & SKEL_LEFT_HAND.y > 285 & SKEL_LEFT_HAND.y < 295
\end_layout

\begin_layout Plain Layout

    & rightTopDrum == false) 
\end_layout

\begin_layout Plain Layout

    | (SKEL_RIGHT_HAND.x > 325 & SKEL_RIGHT_HAND.x < 335
\end_layout

\begin_layout Plain Layout

    & SKEL_RIGHT_HAND.y > 285 & SKEL_RIGHT_HAND.y < 295 
\end_layout

\begin_layout Plain Layout

    & rightTopDrum == false))
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      // cargue el sonido
\end_layout

\begin_layout Plain Layout

      player = minim.loadFile("rightTopDrum.wav");
\end_layout

\begin_layout Plain Layout

      // reproduzca el archivo
\end_layout

\begin_layout Plain Layout

      player.play();
\end_layout

\begin_layout Plain Layout

      rightTopDrum = true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      rightTopDrum = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} // void rightTopDrum()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Si las manos del usuario son rastreadas en el area del tomb de abajo derecho,
\end_layout

\begin_layout Plain Layout

entonces toque un sonido.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void rightBottomDrum()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if((SKEL_LEFT_HAND.x > 385 & SKEL_LEFT_HAND.x < 395
\end_layout

\begin_layout Plain Layout

    & SKEL_LEFT_HAND.y > 340 & SKEL_LEFT_HAND.y < 350
\end_layout

\begin_layout Plain Layout

    & rightBottomDrum == false) 
\end_layout

\begin_layout Plain Layout

    | (SKEL_RIGHT_HAND.x > 385 & SKEL_RIGHT_HAND.x <395
\end_layout

\begin_layout Plain Layout

    & SKEL_RIGHT_HAND.y > 340 & SKEL_RIGHT_HAND.y < 350 
\end_layout

\begin_layout Plain Layout

    & rightBottomDrum == false))
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      // cargue el sonido
\end_layout

\begin_layout Plain Layout

      player = minim.loadFile("rightBottomDrum.wav");
\end_layout

\begin_layout Plain Layout

      // reproduzca el archivo
\end_layout

\begin_layout Plain Layout

      player.play();
\end_layout

\begin_layout Plain Layout

      rightBottomDrum = true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      rightBottomDrum = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} // void rightBottomDrum()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Si las manos del usuario son rastreadas en el area de la caja
\end_layout

\begin_layout Plain Layout

entonces toque un sonido.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void snareDrum()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if((SKEL_LEFT_HAND.x > 215 & SKEL_LEFT_HAND.x < 225
\end_layout

\begin_layout Plain Layout

    & SKEL_LEFT_HAND.y > 325 & SKEL_LEFT_HAND.y < 335
\end_layout

\begin_layout Plain Layout

    & snareDrum == false) 
\end_layout

\begin_layout Plain Layout

    | (SKEL_RIGHT_HAND.x > 215 & SKEL_RIGHT_HAND.x < 225
\end_layout

\begin_layout Plain Layout

    & SKEL_RIGHT_HAND.y > 325 & SKEL_RIGHT_HAND.y < 335 
\end_layout

\begin_layout Plain Layout

    & snareDrum == false))
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      // cargue el sonido
\end_layout

\begin_layout Plain Layout

      player = minim.loadFile("snareDrum.wav");
\end_layout

\begin_layout Plain Layout

      // reproduzca el archivo
\end_layout

\begin_layout Plain Layout

      player.play();
\end_layout

\begin_layout Plain Layout

      snareDrum = true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      snareDrum = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} // void snareDrum()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Si las manos del usuario son rastreadas en el area del hihat,
\end_layout

\begin_layout Plain Layout

entonces toque un sonido.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void hihatDrum()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if((SKEL_LEFT_HAND.x > 145 & SKEL_LEFT_HAND.x < 155
\end_layout

\begin_layout Plain Layout

    & SKEL_LEFT_HAND.y > 275 & SKEL_LEFT_HAND.y < 285
\end_layout

\begin_layout Plain Layout

    & hihatDrum == false) 
\end_layout

\begin_layout Plain Layout

    | (SKEL_RIGHT_HAND.x > 145 & SKEL_RIGHT_HAND.x < 155
\end_layout

\begin_layout Plain Layout

    & SKEL_RIGHT_HAND.y > 275 & SKEL_RIGHT_HAND.y < 285 
\end_layout

\begin_layout Plain Layout

    & hihatDrum == false))
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      // cargue el sonido
\end_layout

\begin_layout Plain Layout

      player = minim.loadFile("hihatDrum.wav");
\end_layout

\begin_layout Plain Layout

      // reproduzca el archivo
\end_layout

\begin_layout Plain Layout

      player.play();
\end_layout

\begin_layout Plain Layout

      hihatDrum = true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      hihatDrum = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} // void hihatDrum()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Si las manos del usuario son rastreadas en el area del crash izquierdo
\end_layout

\begin_layout Plain Layout

entonces toque un sonido.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void leftCrashDrum()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if((SKEL_LEFT_HAND.x > 210 & SKEL_LEFT_HAND.x < 220
\end_layout

\begin_layout Plain Layout

    & SKEL_LEFT_HAND.y > 220 & SKEL_LEFT_HAND.y < 230
\end_layout

\begin_layout Plain Layout

    & leftCrashDrum == false) 
\end_layout

\begin_layout Plain Layout

    | (SKEL_RIGHT_HAND.x > 210 & SKEL_RIGHT_HAND.x < 220
\end_layout

\begin_layout Plain Layout

    & SKEL_RIGHT_HAND.y > 220 & SKEL_RIGHT_HAND.y < 230 
\end_layout

\begin_layout Plain Layout

    & leftCrashDrum == false))
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      // cargue el sonido
\end_layout

\begin_layout Plain Layout

      player = minim.loadFile("leftCrashDrum.wav");
\end_layout

\begin_layout Plain Layout

      // reproduzca el archivo
\end_layout

\begin_layout Plain Layout

      player.play();
\end_layout

\begin_layout Plain Layout

      leftCrashDrum = true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      leftCrashDrum = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} // void leftCrashDrum()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Si las manos del usuario son rastreadas en el area del crash central,
\end_layout

\begin_layout Plain Layout

entonces toque un sonido.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void centerCrashDrum()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if((SKEL_LEFT_HAND.x > 280 & SKEL_LEFT_HAND.x < 290
\end_layout

\begin_layout Plain Layout

    & SKEL_LEFT_HAND.y > 220 & SKEL_LEFT_HAND.y < 230
\end_layout

\begin_layout Plain Layout

    & centerCrashDrum == false) 
\end_layout

\begin_layout Plain Layout

    | (SKEL_RIGHT_HAND.x > 280 & SKEL_RIGHT_HAND.x < 290
\end_layout

\begin_layout Plain Layout

    & SKEL_RIGHT_HAND.y > 220 & SKEL_RIGHT_HAND.y < 230 
\end_layout

\begin_layout Plain Layout

    & centerCrashDrum == false))
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      // cargue el sonido
\end_layout

\begin_layout Plain Layout

      player = minim.loadFile("centerCrashDrum.wav");
\end_layout

\begin_layout Plain Layout

      // reproduzca el archivo
\end_layout

\begin_layout Plain Layout

      player.play();
\end_layout

\begin_layout Plain Layout

      centerCrashDrum = true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      centerCrashDrum = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} // void centerCrashDrum()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Si las manos del usuario son rastreadas en el area del crash derecho,
\end_layout

\begin_layout Plain Layout

entonces toque un sonido.
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void rightCrashDrum()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if((SKEL_LEFT_HAND.x > 395 & SKEL_LEFT_HAND.x < 405
\end_layout

\begin_layout Plain Layout

    & SKEL_LEFT_HAND.y > 225 & SKEL_LEFT_HAND.y < 235
\end_layout

\begin_layout Plain Layout

    & rightCrashDrum == false) 
\end_layout

\begin_layout Plain Layout

    | (SKEL_RIGHT_HAND.x > 395 & SKEL_RIGHT_HAND.x < 405
\end_layout

\begin_layout Plain Layout

    & SKEL_RIGHT_HAND.y > 225 & SKEL_RIGHT_HAND.y < 235 
\end_layout

\begin_layout Plain Layout

    & rightCrashDrum == false))
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      // cargue sonido
\end_layout

\begin_layout Plain Layout

      player = minim.loadFile("rightCrashDrum.wav");
\end_layout

\begin_layout Plain Layout

      // reproduzca el archivo
\end_layout

\begin_layout Plain Layout

      player.play();
\end_layout

\begin_layout Plain Layout

      rightCrashDrum = true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

      rightCrashDrum = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} // void rightCrashDrum()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/**----------------------------------------------------------
\end_layout

\begin_layout Plain Layout

Si el usuario presiona el botón conetado a Arduino, 
\end_layout

\begin_layout Plain Layout

entonces toque un sonido
\end_layout

\begin_layout Plain Layout

-----------------------------------------------------------*/
\end_layout

\begin_layout Plain Layout

void kickDrum()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if(arduino.digitalRead(switchPin)==Arduino.LOW)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        kickDrum = false;
\end_layout

\begin_layout Plain Layout

      // cargue el sonido
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

          player = minim.loadFile("kickDrum.wav");
\end_layout

\begin_layout Plain Layout

      // reproduzca el archivo
\end_layout

\begin_layout Plain Layout

      player.play();
\end_layout

\begin_layout Plain Layout

      kickDrum = true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

} // void kickDrum()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Código Final
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusión.
\end_layout

\begin_layout Standard
Al concluir este proyecto se da cuenta de las grandes ventajas que provee
 el IDE Processing para el manejo del arduino y la kinect para el propósito,
 también se puede apreciar la gran fluidez del este lenguaje y a su vez
 la kinect provee un gran manejo y control sobre el reconocimiento con la
 camara que ésta posee para nuestro propósito y que con arduino se puede
 abarcar mucho más de lo imaginado (el límite es la imaginacion).
\end_layout

\begin_layout Standard
Se verifica que a pesar que la kinect al ser desarrollado por microsoft
 se desenvuelve perfectamente en sistemas basados en unix (gnu/linux, mac),
 mientras que arduino al ser un hardware libre no presentas problemas para
 trabajar en cualquier S.O.
 Cabe destacar que aún existen conflictos entre programas de 32 y 64 bits
 que no han sido solucionados o en sus versiones previas (en el caso de
 processing 2.0 de 32 y 64 y processing 2.0 y 1.5).
 
\end_layout

\begin_layout Standard
Para finalizar, wiimote era una idea factible, pero no para nuestro objetivo
 final debido a falta de librerias, errores e incompatibilidades con processing
 referente a diversos S.O.
 existentes.
\end_layout

\begin_layout Section
Bibliografía.
\end_layout

\end_body
\end_document
